#summary 第二个教程 映射路由分库分表MapRoute使用

= 简介 =
在很多应用中，取模分表分库不能满足需求。例如在仓库管理的应用中，<br/>北京的货物需存在在北京的仓库，上海的货物需存在在上海的仓库。<br/>再如在CRM系统中，用户信息需分公司编号分库，北京分公司存入北分库，上海分公司存入上海分库等等。那么之前讲诉的分库是不能满足，于是本人编写了MapRoute来应对。

= 详细 =
==映射路由分库分表配置说明如下：==
{{{
配置一：user_info.unitPosId={99:user0;100:user1;101:user2;XXXXX:userxxx
表示user_info对分库字段unitPosId做映射，
映射关系是99在库user0上，100在库user1上，101在库user2上
调用MapRoute.getTableName()会带上user_info
}}}

配置二：unitPosId={99:user0;100:user1;101:user2;XXXXX:userxxx}<br>
表示对字段unitPosId做映射，<br>
映射关系是99在库user0上，100在库user1上，101在库user2上<br>
调用MapRoute.getTableName()会不会带上user_info<br>

配置三：user_info.unitPosId={99:user0;100:user1;101:user2;XXXXX:userxxx}#_%s<br>
表示user_info对分库字段unitPosId做映射，<br>
映射关系是99在库user0上，100在库user1上，101在库user2上,并且分表名是key值结尾<br>
调用MapRoute.getTableName()会会带上user_info并以下划线和unitPosId结尾，如：user_info_99<br>


配置四：unitPosId={99:user0;100:user1;101:user2;XXXXX:userxxx}#_%s<br>
表示user_info对分库字段unitPosId做映射，<br>
映射关系是99在库user0上，100在库user1上，101在库user2上,并且分表名是key值结尾<br>
调用MapRoute.getTableName()会不会带上user_info并以下划线和unitPosId结尾，如：_99<br>




使用如下：<br>

{{{
public static void main(String[] args) throws Exception {
	final String ruleConfig = "user_info.unitPosId={beijing:user_bj;nanchang:user_nc}#_%s";
	MapRoute mapRoute = new MapRoute();
	mapRoute.parseRouteConfig(ruleConfig);
	
	System.out.println("分表分库配置"+ruleConfig);
	for (Map.Entry<String, String> e: mapRoute.getRouteRuleMap().entrySet()) {
		mapRoute.setRouteId(e.getKey());
		
		System.out.print(String.format("routeId = %s -->",e.getKey()));
		System.out.print(String.format("TableName   is %s ", mapRoute.getTableName()));
		System.out.print(String.format("DBGroupName is %s", mapRoute.getDBGroupName()));
		System.out.println();
	}
}
}}}
获取到如下结果：
{{{
分表分库配置user_info.unitPosId={beijing:user_bj;nanchang:user_nc}#_%s
routeId = nanchang -->TableName   is user_info_nanchang DBGroupName is user_nc
routeId = beijing -->TableName   is user_info_beijing DBGroupName is user_bj
}}}